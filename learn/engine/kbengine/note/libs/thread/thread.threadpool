问题：ThreadPool类设计说明？
试答：ThreadPool类被设计用来管理TPThread类的创建，使用，回收和销毁。
	  
	  它用三个列表：繁忙的线程列表、闲置的线程列表、所有的线程列表，来达到以上的目的，
	  
	  同时设计了一套线程创建规则：1，规定最大线程数，避免出现线程无休止创建；2，规定
	  常用线程数，在压力不大的情况下，可以不用创建过多的线程浪费资源；3，规定新建
	  线程数，在承压较大的情况下，遇到线程不足时，需要创建的新的线程数。
	  
	  当ThreadPool新增一个任务时，就会从闲置的线程列表中取出一个线程来处理任务，同时加入
	  到繁忙的线程列表中；当TPThread类中的任务处理完成时，TPThread会回收到空闲列表中，并
	  从繁忙的线程列表中移除。
	  
	  当ThreadPool线程数达到上限且都处于繁忙时，这时需要线程处理的任务，会被缓存起来，待到
	  有空闲线程时，才会被处理。
	  
	  当ThreadPool接收处理的任务完成后，会统一加入到已经完成的任务列表，并在主线程的心跳中
	  处理后续的事务。	  
说明：threadpool.h(233), threadpool.cpp(355)


问题：ThreadPool类是如何进入到工作状态的？
试答：组件的ServerApp类对象在initialize阶段会调用initThreadPool()函数，这个函数做了三件事：
	  1，如果有其他地方初始化过线程池，那么initThreadPool()会返回false，这样ServerApp的initialize
	  也会返回假，最终的结果就是组件启动失败。从这里可以看出，线程池只能有一个地方创建；
	  2，设置线程过期时间；
	  3，创建常用线程。
	  
	  派生于ServerApp类的其他App类在初始化的时候，都会创建一个定时器加入到EventDispatcher的pTimes_
	  定时器管理器中，然后把自己（因为派生于TimerHandler）作为Handler，这样就实现App的心跳功能。
	  
	  ThreadPool类onMainThreadTick()函数就是这App的心跳功能中循环的处理已经完成的线程任务。  
说明：threadpool.cpp(355)


问题：ThreadPool类是addTask()函数说明？
试答：如果闲置的线程列表有线程，那么从中取出一个线程来处理任务，并把这个线程移到繁忙的线程列表中，
	  同时给这个线程发送信号，使其脱离阻塞状态继续执行；
	  
	  在没有闲置的线程的情况下，先把任务添加到缓存列表；
	  
	  如果线程数已经达到最大上限，缓存的任务只能等到有空闲的线程时才能处理，addTask()函数返回；
	  
	  如果可以创建新的线程，那么创建新的线程来处理任务。
	  创建新线程的规则：
	  1，第一个创建的新线程用来处理任务，后面创建的加入闲置的线程列表；
	  2，从缓存列表中取出一个任务来处理，把当前线程加入到繁忙的线程列表；
	  3，如果没有任务了（理论上不可能，因为上面刚加了一个任务），则把线程加入到闲置的线程列表；
	  4，最后调用系统的创建线程函数。	  
说明：threadpool.cpp(552)


问题：TPThread类设计说明？
试答：TPThread被设计用来创建一个实例线程来处理任务，它管理着线程的执行入口函数threadFunc()，
	  线程的退出，线程处理的任务数的统计等等。
说明：threadpool.h(61)
	  
	  
问题：TPThread类的createThread()函数说明？
试答：虽然线程的创建是有平台区分的，但执行的逻辑差不多。
	  将TPThread对象本身与这个线程关联起来，执行入口函数threadFunc()。
说明：threadpool.cpp(41)


问题：TPThread类的threadFunc()函数说明？
试答：TPThread类的核心函数，线程启动的时候执行这个函数。
	  
	  函数的参数是TPThread对象本身，在创建线程的时候指定的；
	  进入threadFunc函数时，会重置任务计数reset_done_tasks，执行开始动作onStart()（如果有的话）；
	  
	  接着是函数的主循环while(isRun):
	  如果线程有任务处理，则isRun为true，否则重置任务计数，进入线程等待；	  
	  如果线程池已经销毁了或者isRun为false，goto执行线程结束代码；
	  执行线程结束代码之前，当前线程如果已经释放，需要把关联指针置空；
		  
	  然后是任务处理循环while(task && !tptd->threadPool()->isDestroyed()):
	  如果线程中没有任务，那么重复主循环，否则进入任务处理循环；
	  增加任务计数;
	  处理任务之前动作onProcessTaskStart();
	  处理任务processTask();
	  处理任务之后动作onProcessTaskEnd()；
	  如果没有缓存任务了，则线程处理任务结束，线程挂起状态，任务处理循环结束；
	  如果还有循环任务了，则已经处理的任务加入到完成任务列表，线程设置新的任务，循环继续；
	  
	  当以上循环退出时，执行线程结束代码：
	  如果线程的指针不为空，而且还有任务未处理，这时需要打印警告；
	  执行结束动作onEnd();
	  设置线程结束状态；
	  重置任务计数。
说明：threadpool.cpp(646)
	  
	  


	  