问题：NetworkInterface类设计说明？
试答：NetworkInterface类负责组件的网络通信的管理，他包含了两个连接终点：
	  外部连接终端和内部连接终端，两个终端信息接收器：外部终端信息接收器和内部终端信息接收器，
	  同时维护着一份通信列表。
	  每个组件启动的时候，会根据组件的配置，创建一个NetwoInterface对象，
	  依次创建两个终端，和对应的两个信息接收器，并将两者关联起来（epoll注册）。
	  派生于TimerHandler，但处理函数目前没有具体逻辑，可以认为暂时没有应用。
说明：network_interface.h


问题：NetworkInterface类构造函数？
试答：成员变量的初始化，外部和内部终端的建立，负责外部和内部终端接收器的创建。
	  关联终端和对应的信息接收器。
	  初始化延迟频道管理器pDelayedChannels_。
说明：network_interface.cpp(25)


问题：NetworkInterface类析构函数？
试答：释放通信信息，关闭socket，释放各种资源。
说明：network_interface.cpp(88)


问题：NetworkInterface类extTcpAddr()？
试答：获取对外的tcp地址，是一个Address类结构，NetworkInterface::initialize()函数中会对这个结构赋值。
说明：network_interface.h(40)


问题：NetworkInterface类extUdpAddr()？
试答：获取对外的udp地址，是一个Address类结构，NetworkInterface::initialize()函数中会对这个结构赋值。
说明：network_interface.h(41)


问题：NetworkInterface类intTcpAddr()？
试答：获取对内的tcp地址，是一个Address类结构，NetworkInterface::initialize()函数中会对这个结构赋值。
说明：network_interface.h(41)


问题：NetworkInterface类initialize()？
试答：参数是监听终端的类型（tcp/udp）名称，监听的最小端口最大端口，监听的地址，监听终端，监听信息接收器，
	  可读缓存，可写缓存。
	  如果终端已经建立了，那么先释放，这里做了重复利用资源的事情；
	  创建socket类型，并且将它的文件描述符的监听接收器与函数传来的监听接收器关联；
	  如果端口上限和下限一样，则设置端口重用，防止意外情况这个端口没有被释放，导致无法绑定；
	  --可以对一个端口进行多次绑定，一般这个是不支持使用的；对于监听套接字，比较特殊。
	  --如果你定义了SO_REUSEADDR，并且让两个套接字在同一个端口上进行接听，那么对于由谁来ACCEPT，
	  --就会出现歧义。如果你定义个SO_REUSEADDR，只定义一个套接字在一个端口上进行监听，
	  --如果服务器出现意外而导致没有将这个端口释放，那么服务器重新启动后，你还可以用这个端口，
	  --因为你已经规定可以重用了，如果你没定义的话，你就会得到提示，ADDR已在使用中。 	  
	  验证网络地址是否可以使用；
	  查找端口并且绑定，绑定不成功进程退出；
	  获取绑定的地址，如果地址ip为0，就获取默认的地址，失败退出；
	  监听不阻塞，不延迟；
	  设置读写缓存大小；
	  如果是tcp则调用listen接口。	  
	  #todo需要继续深究。
说明：network_interface.h(44)



问题：NetworkInterface类的recreateListeningSocket()函数说明？
试答：参数说明：
	  1，pEndPointName，终点名称，用于日志信息打印；
	  2，listeningPort_min，监听的最小端口；
	  3，listeningPort_max，监听的最大端口；
	  4，listeningInterface，指定的接口名 NIP,MAC,IP等
	  5，pEP，连接终点；
	  6，pLR，终点监听；
	  7，rbuffer，读取缓存大小；
	  8，wbuffer，写入缓存大小。
	  
	  过程说明：
	  首先是断言，要求listeningInterface，pEP，pLR指针非空；
	  如果pEP已经是有效的scoket的话，这里先释放掉；
	  从这个设计来看，该函数不单单只在构造函数的时候可以，其他地方也可以调用；
	  创建socket，并对他进行验证，如果验证不通过则打印错误日志并返回失败；
	  如果配置的最小监听端口和最大监听端口一样，那么设置端口复用，避免绑定的时候失败；
	  向底层注册文件描述符，关联pEP和pLR；
	  查找指定接口名，通常配置为空，但某些情况下会需要这个配置；
	  尝试绑定端口，如果端口被占用则向后递增；如果绑定失败，则报错返回；
	  获取绑定的ip地址，然后设置地址，非阻塞模式，非延迟模式；
	  设置读写缓存大小；
	  最后开始监听。	  
	  
	  总结说明：
	  这个接口是服务器创建网络监听的地方。
说明：network_interface.cpp(131)


问题：NetworkInterface类的通道(Channel)是如何建立的（registerChannel）？
试答：组件的EventDispatcher类的processNetwork()会定时监听网卡上的socket事件，然后提交
	  给相应的handler处理。
	  
	  NetworkInterface类在构造的时候，就把相关的socket（EndPoint类对象extEndpoint_，
	  intEndpoint_）和handler（ListenerReceiver类对象pExtListenerReceiver_，
	  pIntListenerReceiver_）关联了起来。
	  
	  当有连接进来的时候，ListenerReceiver类的handleInputNotification()就会处理通道的建立。
说明：event_dispatcher.cpp(188), poller_epoll.cpp(107), event_poller.cpp(93), listener_receiver.cpp(54)
	

问题：NetworkInterface类的通道(Channel)是如何取消的（deregisterChannel）？	
试答：会取消Channel注册的几种情况：
	  1，通道超时，最后一次通信时间超过配置时间（60.0s）则被认定为超时通道， 服务器将踢出该通道；
	  2，当通道变的不合法的时候；
	  3，收到协议包出错的时候；
说明：serverapp.cpp(305),network_interface.cpp(425),tcp_packet_receiver.cpp(131),udp_packet_receiver.cpp(135)


问题：NetworkInterface类的通道(Channel)的超时处理流程(pChannelTimeOutHandler())？
试答：每个Channel创建的时候，会相应的创建一个定时器,用来检测通道是否过期；
	  如果通道过期，会调用NetworkInterface类的onChannelTimeOut()函数，该函数内部主要是
	  调用ServerApp类的onChannelTimeOut()函数，这个函数会调用NetworkInterface类的deregisterChannel()
	  来注销通道，同时调用Channel的destroy()接口销毁Channel，并归还内存给内存池。
	  
	  在NetworkInterface类的deregisterChannel()函数中，移除通道之后，还要处理相关的善后工作，
	  如果是内部通道，那就要处理组件移除的事情。
	  
说明：channel.cpp(242, 280),network_interface.cpp(410, 381),serverapp.cpp(305)


问题：NetworkInterface类是如何使用他所管理的通道呢，用他们做什么呢,（processChannels()函数说明）？
试答：服务器的每个组件都有一个定时器来处理组件的定时事务，其中的一个事务就是调用NetworkInterface类
	  processChannels()函数。
	  在processChannels()函数中，主要处理失效通道的注销和收到消息的处理。
	  
	  
问题：NetworkInterface类的延迟发送时什么目的，延迟流程是怎样的呢？
试答：这里延迟发送，其实就是把发送的信息缓存到下一帧去发送。
	  NetworkInterface类有个成员变量DelayedChannels类的指针pDelayedChannels_，专门负责延迟消息的处理。
	  每当有要延迟的消息（目前看来是日记系统用到了这个机制），NetworkInterface的delayedSend接口负责往
	  DelayedChannels类pDelayedChannels_指向对象添加需要延迟发送的Channel。
	  
	  DelayedChannels类是Task类的子类，在初始化的时候，把自己加入了任务事务的处理队列中，这样每一帧都
	  会检测是否有要延迟发送的Channel，并对其进行处理(send)。
	  
	  因此，延迟发送的Channel最终在下一帧（因为发送包是在任务事务流程之后）的时候发送出去。
说明：network_interface.cpp(295), delayed_channels.h