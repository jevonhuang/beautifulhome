问题：ThreadPool类设计说明？
试答：ThreadPool类被设计用来管理TPThread类的创建，使用，回收和销毁。
	  
	  它用三个列表：繁忙的线程列表、闲置的线程列表、所有的线程列表，来达到以上的目的，
	  
	  同时设计了一套线程创建规则：1，规定最大线程数，避免出现线程无休止创建；2，规定
	  常用线程数，在压力不大的情况下，可以不用创建过多的线程浪费资源；3，规定新建
	  线程数，在承压较大的情况下，遇到线程不足时，需要创建的新的线程数。
	  
	  当ThreadPool新增一个任务时，就会从闲置的线程列表中取出一个线程来处理任务，同时加入
	  到繁忙的线程列表中；当TPThread类中的任务处理完成时，TPThread会回收到空闲列表中，并
	  从繁忙的线程列表中移除。
	  
	  当ThreadPool线程数达到上限且都处于繁忙时，这时需要线程处理的任务，会被缓存起来，待到
	  有空闲线程时，才会被处理。
	  
	  当ThreadPool接收处理的任务完成后，会统一加入到已经完成的任务列表，并在主线程的心跳中
	  处理后续的事务。	  
说明：threadpool.h(233), threadpool.cpp(355)


问题：ThreadPool类是如何进入到工作状态的？
试答：组件的ServerApp类对象在initialize阶段会调用initThreadPool()函数，这个函数做了三件事：
	  1，如果有其他地方初始化过线程池，那么initThreadPool()会返回false，这样ServerApp的initialize
	  也会返回假，最终的结果就是组件启动失败。从这里可以看出，线程池只能有一个地方创建；
	  2，设置线程过期时间；
	  3，创建常用线程。
	  
	  派生于ServerApp类的其他App类在初始化的时候，都会创建一个定时器加入到EventDispatcher的pTimes_
	  定时器管理器中，然后把自己（因为派生于TimerHandler）作为Handler，这样就实现App的心跳功能。
	  
	  ThreadPool类onMainThreadTick()函数就是这App的心跳功能中循环的处理已经完成的线程任务。  
说明：threadpool.cpp(355)


问题：ThreadPool类是addTask()函数说明？
试答：如果闲置的线程列表有线程，那么从中取出一个线程来处理任务，并把这个线程移到繁忙的线程列表中，
	  同时给这个线程发送信号，使其脱离阻塞状态继续执行；
	  
	  在没有闲置的线程的情况下，先把任务添加到缓存列表；
	  
	  如果线程数已经达到最大上限，缓存的任务只能等到有空闲的线程时才能处理，addTask()函数返回；
	  
	  如果可以创建新的线程，那么创建新的线程来处理任务。
	  创建新线程的规则：
	  1，第一个创建的新线程用来处理任务，后面创建的加入闲置的线程列表；
	  2，从缓存列表中取出一个任务来处理，把当前线程加入到繁忙的线程列表；
	  3，如果没有任务了（理论上不肯能，因为上面刚加了一个任务），则把线程加入到闲置的线程列表；
	  4，最后调用系统的创建线程函数。	  
说明：threadpool.cpp(552)


问题：TPThread类说明？
试答：
说明：
	  