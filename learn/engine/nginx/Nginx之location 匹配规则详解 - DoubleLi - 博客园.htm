
<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Nginx之location 匹配规则详解 - DoubleLi - 博客园</title>
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=03KQeESEmpLfzDqUo0NiWUg5Zd5aRam3JHBZTK05Wug1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/Cogitation/bundle-Cogitation.css?v=KxzCsGje7vptXKdp2HZBpXmgRp_h-PvgHFxMy8F9r3o1"/>
<link id="mobile-style" media="only screen and (max-width: 768px)" type="text/css" rel="stylesheet" href="/skins/Cogitation/bundle-Cogitation-mobile.css?v=n-ASw0wkqulya2ufKtWhjTh4rLgmOf1KYWe1yHAgdnc1"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/lidabo/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/lidabo/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/lidabo/wlwmanifest.xml"/>
<script src="//common.cnblogs.com/script/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'lidabo', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="/bundles/blog-common.js?v=hH1lCMV8WaIu271Nx7jPuv36TENW9-RsSxziLxUpjtc1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<div id="top">
	
<div>
	<table>
		<tr>
			<td class="HeaderTitles">
				<h1 class="HeaderTitle"><a id="Header1_HeaderTitle" class="HeaderMainTitle" href="http://www.cnblogs.com/lidabo/">DoubleLi</a></h1>
				<p id="tagline"></p>
			</td>
		</tr>
	</table>
</div>
<div class="HeaderBar">
	<table id="HeaderBar" class="HeaderBar" cellpadding="0" cellspacing="0">
		<tr>
			<td class="HeaderBarTab" nowrap>
&nbsp;
<a id="blog_nav_sitehome" href="http://www.cnblogs.com/">博客园</a> ::
<a id="blog_nav_myhome" href="http://www.cnblogs.com/lidabo/">首页</a> ::
<a href="http://q.cnblogs.com" class="menu">博问</a> ::
<a href="http://home.cnblogs.com/ing/" class="menu">闪存</a> ::
<a id="blog_nav_newpost" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a> ::
<a id="blog_nav_contact" accesskey="9" rel="nofollow" href="https://msg.cnblogs.com/send/DoubleLi">联系</a> ::
<a id="blog_nav_rss" href="http://www.cnblogs.com/lidabo/rss">订阅</a>
<a id="blog_nav_rss_image" class="XMLLink" href="http://www.cnblogs.com/lidabo/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a> ::
<a id="blog_nav_admin" rel="nofollow" href="https://i.cnblogs.com/">管理</a> ::

</td>
			<td><img id="Header1_BlueTab" src="/skins/Cogitation/Images/BlueTabRight.gif" align="absmiddle" /></td>
			<td class="HeaderBarTabBack" nowrap width="100%">
				<div id="blog_stats">
<div class="BlogStatsBar">
	<table class="BlogStatsBar">
		<tr>
			<td width="100%">
			</td>
			<td class="BlogStatsBar" nowrap>
				&nbsp;
				2494 
				随笔&nbsp;::
				2 文章
				::
				229 评论
				::
				0 引用
			</td>
		</tr>
	</table>
</div>
</div>
			</td>
		</tr>
	</table>
</div>

</div>
<div id="leftmenu">	

	    <div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
		
<h3>公告</h3>
<div class="News">
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

		<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
	
</div>
<div id="main">
	
<div id="post_detail">
<div class="post">
	<div class="postTitle">
		<a id="cb_post_title_url" href="http://www.cnblogs.com/lidabo/p/4169396.html">Nginx之location 匹配规则详解</a>
	</div>
	
	<div class="postText">
		<div id="cnblogs_post_body"><h2><a href="http://www.zrqblog.org/?p=699" rel="nofollow" target="_blank">关于一些对location认识的误区</a></h2>
<p><strong>1、&nbsp;location&nbsp;的匹配顺序是&ldquo;先匹配正则，再匹配普通&rdquo;。</strong></p>
<p>矫正：&nbsp;location&nbsp;的匹配顺序其实是&ldquo;先匹配普通，再匹配正则&rdquo;。我这么说，大家一定会反驳我，因为按&ldquo;先匹配普通，再匹配正则&rdquo;解释不了大家平时习惯的按&ldquo;先匹配正则，再匹配普通&rdquo;的实践经验。这里我只能暂时解释下，造成这种误解的原因是：正则匹配会覆盖普通匹配（实际的规则，比这复杂，后面会详细解释）。</p>
<p>&nbsp;</p>
<p><strong>2、&nbsp;location&nbsp;的执行逻辑跟&nbsp;location&nbsp;的编辑顺序无关。</strong></p>
<p>矫正：这句话不全对，&ldquo;普通&nbsp;location&nbsp;&rdquo;的匹配规则是&ldquo;最大前缀&rdquo;，因此&ldquo;普通&nbsp;location&nbsp;&rdquo;的确与&nbsp;location&nbsp;编辑顺序无关；但是&ldquo;正则&nbsp;location&nbsp;&rdquo;的匹配规则是&ldquo;顺序匹配，且只要匹配到第一个就停止后面的匹配&rdquo;；&ldquo;普通location&nbsp;&rdquo;与&ldquo;正则&nbsp;location&nbsp;&rdquo;之间的匹配顺序是？先匹配普通&nbsp;location&nbsp;，再&ldquo;考虑&rdquo;匹配正则&nbsp;location&nbsp;。注意这里的&ldquo;考虑&rdquo;是&ldquo;可能&rdquo;的意思，也就是说匹配完&ldquo;普通&nbsp;location&nbsp;&rdquo;后，有的时候需要继续匹配&ldquo;正则&nbsp;location&nbsp;&rdquo;，有的时候则不需要继续匹配&ldquo;正则&nbsp;location&nbsp;&rdquo;。两种情况下，不需要继续匹配正则&nbsp;location&nbsp;：（&nbsp;1&nbsp;）当普通&nbsp;location&nbsp;前面指定了&ldquo;&nbsp;^~&nbsp;&rdquo;，特别告诉&nbsp;Nginx&nbsp;本条普通&nbsp;location&nbsp;一旦匹配上，则不需要继续正则匹配；（&nbsp;2&nbsp;）当普通location&nbsp;恰好严格匹配上，不是最大前缀匹配，则不再继续匹配正则。</p>
<p><strong>总结一句话： &nbsp;&ldquo;正则 location 匹配让步普通 location 的严格精确匹配结果；但覆盖普通 location 的最大前缀匹配结果&rdquo;</strong></p>
<p>&nbsp;</p>
<h2><a name="t2" rel="nofollow"></a>官方文档解释</h2>
<p>REFER:&nbsp;&nbsp;<a href="http://wiki.nginx.org/NginxHttpCoreModule#location" rel="nofollow">http://wiki.nginx.org/NginxHttpCoreModule#location</a></p>
<p><strong>&nbsp;</strong></p>
<p><strong>location</strong></p>
<p><strong>syntax:&nbsp;</strong><em>location [=|~|~*|^~|@] /uri/ { &hellip; }</em></p>
<p><strong>default:&nbsp;</strong><em>no</em></p>
<p><strong>context:&nbsp;</strong><em>server</em></p>
<p>This directive allows different configurations depending on the URI.</p>
<p>（译者注：1&nbsp;、different configurations depending on the URI&nbsp;说的就是语法格式：location [=|~|~*|^~|@] /uri/ { &hellip; }&nbsp;，依据不同的前缀&ldquo;=&nbsp;&rdquo;，&ldquo;^~&nbsp;&rdquo;，&ldquo;~&nbsp;&rdquo;，&ldquo;~*&nbsp;&rdquo;和不带任何前缀的（因为[A]&nbsp;表示可选，可以不要的），表达不同的含义,&nbsp;简单的说尽管location&nbsp;的/uri/&nbsp;配置一样，但前缀不一样，表达的是不同的指令含义。2&nbsp;、查询字符串不在URI范围内。例如：/films.htm?fid=123&nbsp;的URI&nbsp;是/films.htm&nbsp;。）</p>
<p>It can be configured using both literal strings and regular expressions. To use regular expressions, you must use a prefix:</p>
<ol>
<li>&ldquo;~&rdquo; for case sensitive matching</li>
<li>&ldquo;~*&rdquo; for case insensitive matching</li>
</ol>
<p>译文：上文讲到location /uri/&nbsp;可通过使用不同的前缀，表达不同的含义。对这些不同前缀，分下类，就2&nbsp;大类：正则location&nbsp;，英文说法是location using regular expressions&nbsp;和普通location&nbsp;，英文说法是location using literal strings&nbsp;。那么其中&ldquo;~&nbsp;&rdquo;和&ldquo;~*&nbsp;&rdquo;前缀表示正则location&nbsp;，&ldquo;~&nbsp;&rdquo;区分大小写，&ldquo;~*&nbsp;&rdquo;不区分大小写；其他前缀（包括：&ldquo;=&rdquo;，&ldquo;^~&nbsp;&rdquo;和&ldquo;@&nbsp;&rdquo;）和无任何前缀的都属于普通location&nbsp;。</p>
<p><strong>To determine which&nbsp;<em>location</em>&nbsp;directive matches a particular query, the literal strings are checked first.</strong></p>
<p>译文：对于一个特定的&nbsp;HTTP&nbsp;请求（&nbsp;a particular query&nbsp;），&nbsp;nginx&nbsp;应该匹配哪个&nbsp;location&nbsp;块的指令呢（注意：我们在&nbsp;nginx.conf&nbsp;配置文件里面一般会定义多个&nbsp;location&nbsp;的）？匹配&nbsp;规则是：先匹配普通location&nbsp;（再匹配正则表达式）。注意：官方文档这句话就明确说了，先普通location&nbsp;，而不是有些同学的误区&ldquo;先匹配正则location&nbsp;&rdquo;。</p>
<p><strong>Literal strings match the beginning portion of the query &ndash; the most specific match will be used.</strong></p>
<p>前面说了&ldquo;普通location&nbsp;&rdquo;与&ldquo;正则location&nbsp;&rdquo;之间的匹配规则是：先匹配普通location&nbsp;，再匹配正则location&nbsp;。那么，&ldquo;普通location&nbsp;&rdquo;内部（普通location&nbsp;与普通location&nbsp;）是如何匹配的呢？简单的说：最大前缀匹配。原文：1、match the beginning portion of the query&nbsp;（说的是匹配URI&nbsp;的前缀部分beginning portion&nbsp;）；&nbsp;2&nbsp;、the most specific match will be used&nbsp;（因为location&nbsp;不是&ldquo;严格匹配&rdquo;，而是&ldquo;前缀匹配&rdquo;，就会产生一个HTTP&nbsp;请求，可以&ldquo;前缀匹配&rdquo;到多个普通location&nbsp;，例如：location /prefix/mid/ {}&nbsp;和location /prefix/ {}&nbsp;，对于HTTP&nbsp;请求/prefix/mid/t.html&nbsp;，前缀匹配的话两个location&nbsp;都满足，选哪个？原则是：the most specific match&nbsp;，于是选的是location /prefix/mid/ {}&nbsp;）。</p>
<p><strong>Afterwards, regular expressions are checked in the order defined in the configuration file.&nbsp;</strong>T<strong>he first regular expression to match the query will stop the search.</strong></p>
<p>这段话说了两层意思，第一层是：&ldquo;Afterwards, regular expressions are checked&nbsp;&rdquo;,&nbsp;意思是普通location&nbsp;先匹配，而且选择了最大前缀匹配后，不能就停止后面的匹配，最大前缀匹配只是一个临时的结果，nginx&nbsp;还需要继续检查正则location&nbsp;（但至于最终才能普通location&nbsp;的最大前缀匹配，还是正则location&nbsp;的匹配，截止当前的内容还没讲，但后面会讲）。第二层是&ldquo;regular expressions are checked in the order defined in the configuration file. The first regular expression to match the query will stop the search.&nbsp;&rdquo;，意思是说&ldquo;正则location&nbsp;&rdquo;与&ldquo;正则location&rdquo;内部的匹配规则是：按照正则location&nbsp;在配置文件中的物理顺序（编辑顺序）匹配的（这句话就说明location&nbsp;并不是一定跟顺序无关，只是普通location&nbsp;与顺序无关，正则location&nbsp;还是与顺序有关的），并且只要匹配到一条正则location&nbsp;，就不再考虑后面的（这与&ldquo;普通location&nbsp;&rdquo;与&ldquo;正则location&nbsp;&rdquo;之间的规则不一样，&ldquo;普通location&nbsp;&rdquo;与&ldquo;正则location&nbsp;&rdquo;之间的规则是：选择出&ldquo;普通location&nbsp;&rdquo;的最大前缀匹配结果后，还需要继续搜索正则location&nbsp;）。</p>
<p><strong>If no regular expression matches are found, the result from the literal string search is used.</strong></p>
<p>这句话回答了&ldquo;普通location&nbsp;&rdquo;的最大前缀匹配结果与继续搜索的&ldquo;正则location&nbsp;&rdquo;匹配结果的决策关系。如果继续搜索的&ldquo;正则location&nbsp;&rdquo;也有匹配上的，那么&ldquo;正则location&nbsp;&rdquo;<strong>覆盖</strong>&nbsp;&ldquo;普通location&nbsp;&rdquo;的最大前缀匹配（因为有这个覆盖关系，所以造成有些同学以为正则location&nbsp;先于普通location&nbsp;执行的错误理解）；但是如果&ldquo;正则location&nbsp;&rdquo;没有能匹配上，那么就用&ldquo;普通location&nbsp;&rdquo;的最大前缀匹配结果。</p>
<p>For case insensitive operating systems, like Mac OS X or Windows with Cygwin, literal string matching is done in a case insensitive way (0.7.7). However, comparison is limited to single-byte locale&rsquo;s only.</p>
<p>Regular expression may contain captures (0.7.40), which can then be used in other directives.</p>
<p><strong>It is possible to disable regular expression checks after literal string matching by using &ldquo;^~&rdquo; prefix.If the most specific match literal location has this prefix: regular expressions aren&rsquo;t checked.</strong></p>
<p>通常的规则是，匹配完了&ldquo;普通location&nbsp;&rdquo;指令，还需要继续匹配&ldquo;正则location&nbsp;&rdquo;，但是你也可以告诉Nginx&nbsp;：匹配到了&ldquo;普通location&nbsp;&rdquo;后，不再需要继续匹配&ldquo;正则location&nbsp;&rdquo;了，要做到这一点只要在&ldquo;普通location&nbsp;&rdquo;前面加上&ldquo;^~&nbsp;&rdquo;符号（^&nbsp;表示&ldquo;非&rdquo;，~&nbsp;表示&ldquo;正则&rdquo;，字符意思是：不要继续匹配正则）。</p>
<p>By using the &ldquo;=&rdquo; prefix we define the&nbsp;<strong>exact</strong>&nbsp;match between request URI and location. When matched search stops immediately.&nbsp;E.g., if the request &ldquo;/&rdquo; occurs frequently, using &ldquo;location = /&rdquo; will speed up processing of this request a bit as search will stop after first comparison.</p>
<p>除了上文的&ldquo;^~&nbsp;&rdquo;可以阻止继续搜索正则location&nbsp;外，你还可以加&ldquo;=&nbsp;&rdquo;。那么如果&ldquo;^~&nbsp;&rdquo;和&ldquo;=&nbsp;&rdquo;都能阻止继续搜索正则location&nbsp;的话，那它们之间有什么区别呢？区别很简单，共同点是它们都能阻止继续搜索正则location&nbsp;，不同点是&ldquo;^~&nbsp;&rdquo;依然遵守&ldquo;最大前缀&rdquo;匹配规则，然而&ldquo;=&nbsp;&rdquo;不是&ldquo;最大前缀&rdquo;，而是必须是严格匹配（exact match&nbsp;）。</p>
<p>这里顺便讲下&ldquo;location / {}&nbsp;&rdquo;和&ldquo;location = / {}&nbsp;&rdquo;的区别，&ldquo;location / {}&nbsp;&rdquo;遵守普通location&nbsp;的最大前缀匹配，由于任何URI&nbsp;都必然以&ldquo;/&nbsp;&rdquo;根开头，所以对于一个URI&nbsp;，如果有更specific&nbsp;的匹配，那自然是选这个更specific&nbsp;的，如果没有，&ldquo;/&nbsp;&rdquo;一定能为这个URI&nbsp;垫背（至少能匹配到&ldquo;/&nbsp;&rdquo;），也就是说&ldquo;location / {}&nbsp;&rdquo;有点默认配置的味道，其他更specific的配置能覆盖overwrite&nbsp;这个默认配置（这也是为什么我们总能看到location / {}&nbsp;这个配置的一个很重要的原因）。而&ldquo;location = / {}&nbsp;&rdquo;遵守的是&ldquo;严格精确匹配exact match&nbsp;&rdquo;，也就是只能匹配&nbsp;<a rel="nofollow">http://host:port/&nbsp;</a>请求，同时会禁止继续搜索正则location&nbsp;。因此如果我们只想对&ldquo;GET /&nbsp;&rdquo;请求配置作用指令，那么我们可以选&ldquo;location = / {}&nbsp;&rdquo;这样能减少正则location&nbsp;的搜索，因此效率比&ldquo;location / {}&rdquo;&nbsp;高（注：前提是我们的目的仅仅只想对&ldquo;GET /&nbsp;&rdquo;起作用）。</p>
<p><strong>On exact match with literal location without &ldquo;=&rdquo; or &ldquo;^~&rdquo; prefixes&nbsp;search is also immediately terminated.</strong></p>
<p>前面我们说了，普通location&nbsp;匹配完后，还会继续匹配正则location&nbsp;；但是nginx&nbsp;允许你阻止这种行为，方法很简单，只需要在普通location&nbsp;前加&ldquo;^~&nbsp;&rdquo;或&ldquo;=&nbsp;&rdquo;。但其实还有一种&ldquo;隐含&rdquo;的方式来阻止正则location&nbsp;的搜索，这种隐含的方式就是：当&ldquo;最大前缀&rdquo;匹配恰好就是一个&ldquo;严格精确（exact match&nbsp;）&rdquo;匹配，照样会停止后面的搜索。原文字面意思是：只要遇到&ldquo;精确匹配exact match&nbsp;&rdquo;，即使普通location&nbsp;没有带&ldquo;=&nbsp;&rdquo;或&ldquo;^~&nbsp;&rdquo;前缀，也一样会终止后面的匹配。</p>
<p>先举例解释下，后面例题会用实践告诉大家。假设当前配置是：location /exact/match/test.html {&nbsp;配置指令块1}，location /prefix/ {&nbsp;配置指令块2}&nbsp;和&nbsp;location ~ \.html$ {&nbsp;配置指令块3}&nbsp;，如果我们请求&nbsp;GET /prefix/index.html&nbsp;，则会被匹配到指令块3&nbsp;，因为普通location /prefix/&nbsp;依据最大匹配原则能匹配当前请求，但是会被后面的正则location&nbsp;覆盖；当请求GET /exact/match/test.html&nbsp;，会匹配到指令块1&nbsp;，因为这个是普通location&nbsp;的exact match&nbsp;，会禁止继续搜索正则location&nbsp;。</p>
<p><strong>To summarize, the order in which directives are checked is as follows:</strong></p>
<ol>
<li><strong>Directives with the &ldquo;=&rdquo; prefix that match the query exactly. If found, searching stops.</strong></li>
<li><strong>All remaining directives with conventional strings. If this match used the &ldquo;^~&rdquo; prefix, searching stops.</strong></li>
<li><strong>Regular expressions, in the order they are defined in the configuration file.</strong></li>
<li><strong>If #3 yielded a match, that result is used. Otherwise, the match from #2 is used.</strong></li>
</ol>
<p><strong>这个顺序没必要再过多解释了。但我想用自己的话概括下上面的意思&ldquo;正则&nbsp;location&nbsp;匹配让步普通location&nbsp;的严格精确匹配结果；但覆盖普通&nbsp;location&nbsp;的最大前缀匹配结果&rdquo;。</strong></p>
<p>It is important to know that nginx does the comparison against&nbsp;<strong>decoded&nbsp;</strong>URIs. For example, if you wish to match &ldquo;/images/ /test&rdquo;, then you must use &ldquo;/images/ /test&rdquo; to determine the location.</p>
<p>在浏览器上显示的URL&nbsp;一般都会进行URLEncode&nbsp;，例如&ldquo;空格&rdquo;会被编码为 &nbsp;，但是Nginx&nbsp;的URL&nbsp;的匹配都是针对URLDecode&nbsp;之后的。也就是说，如果你要匹配&ldquo;/images/ /test&nbsp;&rdquo;，你写location&nbsp;的时候匹配目标应该是：&ldquo;/images/ /test&nbsp;&rdquo;。</p>
<p>Example:</p>
<p><a href="http://wiki.nginx.org/NginxHttpCoreModule#location" rel="nofollow">location&nbsp;</a>&nbsp;&nbsp;= / {</p>
<p>&nbsp;# matches the query / only.</p>
<p>&nbsp;[ configuration A ]</p>
<p>}</p>
<p><a href="http://wiki.nginx.org/NginxHttpCoreModule#location" rel="nofollow">location&nbsp;</a>&nbsp;&nbsp;/ {</p>
<p><strong>&nbsp;&nbsp;# matches any query, since all queries begin with /, but regular</strong></p>
<p><strong>&nbsp;&nbsp;# expressions and any longer conventional blocks will be</strong></p>
<p><strong>&nbsp;&nbsp;# matched first.</strong></p>
<p>&nbsp;[ configuration B ]</p>
<p>}</p>
<p><a href="http://wiki.nginx.org/NginxHttpCoreModule#location" rel="nofollow"><strong>location&nbsp;</strong></a>^~ /images/ {</p>
<p><strong>&nbsp;&nbsp;</strong>&nbsp;&nbsp;# matches any query beginning with /images/ and halts searching,</p>
<p>&nbsp;# so regular expressions will not be checked.</p>
<p>&nbsp;[ configuration C ]</p>
<p>}</p>
<p><a href="http://wiki.nginx.org/NginxHttpCoreModule#location" rel="nofollow">location&nbsp;</a>~* \.(gif|jpg|jpeg)$ {</p>
<p>&nbsp;# matches any request ending in gif, jpg, or jpeg. However, all</p>
<p>&nbsp;# requests to the /images/ directory will be handled by</p>
<p>&nbsp;# Configuration C.&nbsp;&nbsp;</p>
<p>&nbsp;[ configuration D ]</p>
<p>}</p>
<p>&nbsp;</p>
<p>上述这4&nbsp;个location&nbsp;的配置，没什么好解释的，唯一需要说明的是location / {[configuration B]}&nbsp;，原文的注释严格来说是错误的，但我相信原文作者是了解规则的，只是文字描述上简化了下，但这个简化容易给读者造成&ldquo;误解：先检查正则location&nbsp;，再检查普通location&nbsp;&rdquo;。原文：&ldquo;matches any query, since all queries begin with /,&nbsp;but<strong>regular expressions</strong>&nbsp;and any longer conventional blocks&nbsp;<strong>will be matched first.&nbsp;</strong>&rdquo;大意是说：&ldquo;location / {}&nbsp;能够匹配所有HTTP&nbsp;请求，因为任何HTTP&nbsp;请求都必然是以&lsquo;/&nbsp;&rsquo;开始的（这半句没有错误）。<strong>但是，正则location&nbsp;</strong>和其他任何比&lsquo;/&nbsp;&rsquo;更长的普通location&nbsp;（location / {}&nbsp;是普通location&nbsp;里面最短的，因此其他任何普通location&nbsp;都会比它更长，当然location = / {}&nbsp;和&nbsp;location ^~ / {}&nbsp;是一样长的）<strong>会优先匹配（matched first&nbsp;）。&rdquo;&nbsp;</strong>原文作者说&ldquo;&nbsp;but regular expressions will be matched first.&nbsp;&rdquo;应该只是想说正则&nbsp;location&nbsp;会覆盖这里的&nbsp;location / {}&nbsp;，但依然是普通location / {}&nbsp;先于正则&nbsp;location&nbsp;匹配，接着再正则&nbsp;location&nbsp;匹配；但其他更长的普通&nbsp;location&nbsp;（&nbsp;any longer conventional blocks&nbsp;）的确会先于&nbsp;location / {}&nbsp;匹配。</p>
<p>&nbsp;</p>
<p>Example requests:</p>
<ul>
<li>/ -&gt; configuration A</li>
<li>/documents/document.html -&gt; configuration B</li>
<li>/images/1.gif -&gt; configuration C</li>
<li>/documents/1.jpg -&gt; configuration D</li>
</ul>
<p><strong>Note that you could define these 4 configurations in any order and the results would remain the same.</strong></p>
<p>需要提醒下：这里说&ldquo;in any order&nbsp;&rdquo;和&ldquo;&hellip; remain the same&nbsp;&rdquo;是因为上面只有一个正则location&nbsp;。文章前面已经说了正则location&nbsp;的匹配是跟编辑顺序有关系的。</p>
<p><strong>While nested locations are allowed by the configuration file parser, their use is discouraged and may produce unexpected results.</strong></p>
<p>实际上&nbsp;nginx&nbsp;的配置文件解析程序是允许&nbsp;location&nbsp;嵌套定义的（&nbsp;location / { location /uri/ {} }&nbsp;）。但是我们平时却很少看见这样的配置，那是因为&nbsp;nginx&nbsp;官方并不建议大家这么做，因为这样会导致很多意想不到的后果。</p>
<p><strong>The prefix &ldquo;@&rdquo; specifies a named location. Such locations are not used during normal processing of requests, they are intended only to process internally redirected requests (see&nbsp;</strong><a title="HttpCoreModule" href="http://wiki.nginx.org/HttpCoreModule#error_page" rel="nofollow"><strong>error_page&nbsp;</strong></a><strong>,</strong><a title="HttpCoreModule" href="http://wiki.nginx.org/HttpCoreModule#try_files" rel="nofollow"><strong>try_files&nbsp;</strong></a><strong>).</strong></p>
<p>文章开始说了location&nbsp;的语法中，可以有&ldquo;=&nbsp;&rdquo;，&ldquo;^~&nbsp;&rdquo;，&ldquo;~&nbsp;&rdquo;和&ldquo;~*&nbsp;&rdquo;前缀，或者干脆没有任何前缀，还有&ldquo;@&nbsp;&rdquo;前缀，但是后面的分析我们始终没有谈到&ldquo;@&nbsp;&rdquo;前缀。文章最后点内容，介绍了&ldquo;＠&rdquo;的用途：&ldquo;@&nbsp;&rdquo;是用来定义&ldquo;Named Location&nbsp;&rdquo;的（你可以理解为独立于&ldquo;普通location&nbsp;（location using literal strings&nbsp;）&rdquo;和&ldquo;正则location&nbsp;（location using regular expressions&nbsp;）&rdquo;之外的第三种类型），这种&ldquo;Named Location&nbsp;&rdquo;不是用来处理普通的HTTP&nbsp;请求的，它是专门用来处理&ldquo;内部重定向（internally redirected&nbsp;）&rdquo;请求的。注意：这里说的&ldquo;内部重定向（internally redirected&nbsp;）&rdquo;或许说成&ldquo;forward&nbsp;&rdquo;会好点，以为内internally redirected&nbsp;是不需要跟浏览器交互的，纯粹是服务端的一个转发行为。</p>
<p>&nbsp;</p>
<h2><a name="t3" rel="nofollow"></a>安装Nginx</h2>
<p>wget &nbsp; &nbsp;&nbsp;<a title="nginx" href="http://nginx.org/download/nginx-1.4.6.tar.gz" rel="nofollow" target="_blank">http://nginx.org/download/nginx-1.4.6.tar.gz</a></p>
<p>tar zxvf nginx-1.1.0.tar.gz</p>
<p>./configure</p>
<p>make</p>
<p>make install</p>
<p><strong>需要注意的是在&nbsp;configure&nbsp;这步遇到点小麻烦：</strong></p>
<p>./configure: error: the HTTP rewrite module requires the PCRE library.</p>
<p>安装&nbsp;nginx&nbsp;的时候，&nbsp;rewrite&nbsp;模块默认是需要被安装的。但是&nbsp;rewrite&nbsp;模块所依赖的&nbsp;PCRE&nbsp;库需要额外安装。</p>
<p>You can either disable the module by using &ndash;without-http_rewrite_module</p>
<p>option, or install the PCRE library into the system, or build the PCRE library</p>
<p>statically from the source with nginx by using &ndash;with-pcre=&lt;path&gt; option.</p>
<p>&nbsp;</p>
<p>解决办法：&nbsp;<a href="http://apps.hi.baidu.com/share/detail/34331473" rel="nofollow">http://apps.hi.baidu.com/share/detail/34331473</a></p>
<p>先执行：&nbsp;yum -y install pcre-devel openssl openssl-devel&nbsp;&nbsp;把依赖的东西安装上。</p>
<p>备注：&nbsp;<strong>PCRE</strong>&nbsp;(<strong>Perl Compatible Regular Expressions</strong>&nbsp;)是perl语言正则表达式。 Nginx的rewrite的正则表达式采用的是Perl语法集（常识：正则表达式有不同的语法集，我们常见的grep指令如果需要采用Perl语法集，需要grep -P 来指定）。</p>
<p>&nbsp;</p>
<p><strong>location&nbsp;实例练习</strong></p>
<p>Nginx&nbsp;的语法形式是：&nbsp;location [=|~|~*|^~|@] /uri/ { &hellip; }&nbsp;，意思是可以以&ldquo;&nbsp;=&nbsp;&rdquo;或&ldquo;&nbsp;~*&nbsp;&rdquo;或&ldquo;&nbsp;~&nbsp;&rdquo;或&ldquo;&nbsp;^~&nbsp;&rdquo;或&ldquo;&nbsp;@&nbsp;&rdquo;符号为前缀，当然也可以没有前缀（因为&nbsp;[A]&nbsp;是表示可选的&nbsp;A&nbsp;；&nbsp;A|B&nbsp;表示&nbsp;A&nbsp;和&nbsp;B&nbsp;选一个），紧接着是&nbsp;/uri/&nbsp;，再接着是{&hellip;}&nbsp;指令块，整个意思是对于满足这样条件的&nbsp;/uri/&nbsp;适用指令块&nbsp;{&hellip;}&nbsp;的指令。</p>
<p>上述各种&nbsp;location&nbsp;可分两大类，分别是：&ldquo;普通&nbsp;location&nbsp;&rdquo;，官方英文说法是&nbsp;location using&nbsp;&nbsp;&nbsp;literal strings&nbsp;和&ldquo;正则&nbsp;location&nbsp;&rdquo;，英文说法是&nbsp;location using&nbsp;<strong>regular expressions</strong>&nbsp;。其中&ldquo;普通&nbsp;location&nbsp;&rdquo;是以&ldquo;&nbsp;=&nbsp;&rdquo;或&ldquo;&nbsp;^~&nbsp;&rdquo;为前缀或者没有任何前缀的&nbsp;/uri/&nbsp;；&ldquo;正则&nbsp;location&nbsp;&rdquo;是以&ldquo;&nbsp;~&nbsp;&rdquo;或&ldquo;&nbsp;~*&nbsp;&rdquo;为前缀的&nbsp;/uri/&nbsp;。</p>
<p>那么，当我们在一个&nbsp;server&nbsp;上下文编写了多个&nbsp;location&nbsp;的时候，&nbsp;Nginx&nbsp;对于一个&nbsp;HTTP&nbsp;请求，是如何匹配到一个&nbsp;location&nbsp;做处理呢？用一句话简单概括&nbsp;Nginx&nbsp;的&nbsp;location&nbsp;匹配规则是：&ldquo;正则&nbsp;location&nbsp;&rdquo;<strong>让步</strong>&nbsp;&ldquo;普通&nbsp;location&rdquo;的严格精确匹配结果；但<strong>覆盖</strong>&nbsp;&ldquo;普通&nbsp;location&nbsp;&rdquo;的最大前缀匹配结果。理解这句话，我想通过下面的实例来说明。</p>
<h3><a name="t4" rel="nofollow"></a>#1&nbsp;先普通&nbsp;location&nbsp;，再正则&nbsp;location</h3>
<p>周边不少童鞋告诉我，&nbsp;nginx&nbsp;是&ldquo;先匹配正则&nbsp;location&nbsp;再匹配普通&nbsp;location&nbsp;&rdquo;，其实这是一个误区，&nbsp;nginx&nbsp;其实是&ldquo;先匹配普通&nbsp;location&nbsp;，再匹配正则&nbsp;location&nbsp;&rdquo;，但是普通&nbsp;location&nbsp;的匹配结果又分两种：一种是&ldquo;严格精确匹配&rdquo;，官方英文说法是&ldquo;&nbsp;exact match&nbsp;&rdquo;；另一种是&ldquo;最大前缀匹配&rdquo;，官方英文说法是&ldquo;&nbsp;Literal strings match the beginning portion of the query &ndash; the most specific match will be used.&nbsp;&rdquo;。我们做个实验：</p>
<p>&nbsp;</p>
<p>例题&nbsp;1&nbsp;：假设&nbsp;nginx&nbsp;的配置如下</p>
<p>server {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9090;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;localhost;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location / {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;&nbsp;html;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;&nbsp;index.html index.htm;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location ~ \.html$ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>附录&nbsp;nginx&nbsp;的目录结构是：&nbsp;nginx-&gt;html-&gt;index.html</p>
<p>上述配置的意思是：&nbsp;location / {&hellip; deny all;}&nbsp;普通&nbsp;location&nbsp;以&ldquo;&nbsp;/&nbsp;&rdquo;开始的&nbsp;URI&nbsp;请求（注意任何&nbsp;HTTP&nbsp;请求都必然以&ldquo;/&nbsp;&rdquo;开始，所以&ldquo;&nbsp;/&nbsp;&rdquo;的意思是所有的请求都能被匹配上），都拒绝访问；&nbsp;location ~\.html$ {allow all;}&nbsp;正则&nbsp;location以&nbsp;.html&nbsp;结尾的&nbsp;URI&nbsp;请求，都允许访问。</p>
<p>&nbsp;</p>
<p>测试结果：</p>
<p>[root@web108 ~]#&nbsp;<strong>curl http://localhost:9090/</strong></p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</p>
<p>&lt;body bgcolor=&rdquo;white&rdquo;&gt;</p>
<p>&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</p>
<p>&lt;hr&gt;&lt;center&gt;nginx/1.1.0&lt;/center&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>[root@web108 ~]#&nbsp;<strong>curl http://localhost:9090/index.html</strong></p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;</p>
<p>&lt;title&gt;Welcome to nginx!&lt;/title&gt;</p>
<p>&lt;/head&gt;</p>
<p>&lt;body bgcolor=&rdquo;white&rdquo; text=&rdquo;black&rdquo;&gt;</p>
<p>&lt;center&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;/center&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>[root@web108 ~]#&nbsp;<strong>curl http://localhost:9090/index_notfound.html</strong></p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;</p>
<p>&lt;body bgcolor=&rdquo;white&rdquo;&gt;</p>
<p>&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;</p>
<p>&lt;hr&gt;&lt;center&gt;nginx/1.1.0&lt;/center&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>[root@web108 ~]#</p>
<p>&nbsp;</p>
<p>测试结果如下：</p>
<table>
<tbody>
<tr>
<td width="310">URI&nbsp;请求</td>
<td width="259">HTTP&nbsp;响应</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/</td>
<td width="259">403 Forbidden</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/index.html</td>
<td width="259">Welcome to nginx!</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/index_notfound.html</td>
<td width="259">404 Not Found</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>curl&nbsp;<a href="http://localhost:9090/" rel="nofollow">http://localhost:9090/</a>&nbsp;的结果是&ldquo;&nbsp;403 Forbidden&nbsp;&rdquo;，说明被匹配到&ldquo;&nbsp;location / {..deny all;}&nbsp;&rdquo;了，原因很简单HTTP&nbsp;请求&nbsp;GET /&nbsp;被&ldquo;严格精确&rdquo;匹配到了普通&nbsp;location / {}&nbsp;，则会停止搜索正则&nbsp;location&nbsp;；</p>
<p>curl&nbsp;<a href="http://localhost:9090/index.html" rel="nofollow">http://localhost:9090/index.html</a>&nbsp;结果是&ldquo;&nbsp;Welcome to nginx!&nbsp;&rdquo;，说明没有被&ldquo;&nbsp;location / {&hellip;deny all;}&nbsp;&rdquo;匹配，否则会&nbsp;403 Forbidden&nbsp;，但&nbsp;/index.html&nbsp;的确也是以&ldquo;&nbsp;/&nbsp;&rdquo;开头的，只不过此时的普通&nbsp;location /&nbsp;的匹配结果是&ldquo;最大前缀&rdquo;匹配，所以&nbsp;Nginx&nbsp;会继续搜索正则&nbsp;location&nbsp;，&nbsp;location ~ \.html$&nbsp;表达了以&nbsp;.html&nbsp;结尾的都&nbsp;allow all;&nbsp;于是接着就访问到了实际存在的&nbsp;index.html&nbsp;页面。</p>
<p>curl&nbsp;<a href="http://localhost:9090/index_notfound.html" rel="nofollow">http://localhost:9090/index_notfound.html</a>&nbsp;&nbsp;&nbsp;同样的道理先匹配&nbsp;location / {}&nbsp;，但属于&ldquo;普通&nbsp;location&nbsp;的最大前缀匹配&rdquo;，于是后面被&ldquo;正则&nbsp;location&nbsp;&rdquo;&nbsp;location ~ \.html$ {}&nbsp;覆盖了，最终&nbsp;allow all&nbsp;；&nbsp;但的确目录下不存在index_notfound.html&nbsp;页面，于是&nbsp;404 Not Found&nbsp;。</p>
<p>&nbsp;</p>
<p>如果此时我们访问&nbsp;<a href="http://localhost:9090/index.txt" rel="nofollow">http://localhost:9090/index.txt</a>&nbsp;会是什么结果呢？显然是&nbsp;deny all&nbsp;；因为先匹配上了&nbsp;location / {..deny all;}&nbsp;尽管属于&ldquo;普通&nbsp;location&nbsp;&rdquo;的最大前缀匹配结果，继续搜索正则&nbsp;location&nbsp;，但是&nbsp;/index.txt&nbsp;不是以&nbsp;.html结尾的，正则&nbsp;location&nbsp;失败，最终采纳普通&nbsp;location&nbsp;的最大前缀匹配结果，于是&nbsp;deny all&nbsp;了。</p>
<p>[root@web108 ~]#&nbsp;<strong>curl http://localhost:9090/index.txt</strong></p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</p>
<p>&lt;body bgcolor=&rdquo;white&rdquo;&gt;</p>
<p>&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</p>
<p>&lt;hr&gt;&lt;center&gt;nginx/1.1.0&lt;/center&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>[root@web108 ~]#</p>
<h3><a name="t5" rel="nofollow"></a>#2&nbsp;普通&nbsp;location&nbsp;的&ldquo;隐式&rdquo;严格匹配</h3>
<p>例题&nbsp;2&nbsp;：我们在例题&nbsp;1&nbsp;的基础上增加精确配置</p>
<p>&nbsp;</p>
<p>server {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9090;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;localhost;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location /exact/match.html {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location / {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;&nbsp;html;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;&nbsp;index.html index.htm;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location ~ \.html$ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>&nbsp;</p>
<p>测试请求：</p>
<p>[root@web108 ~]#&nbsp;<strong>curl http://localhost:9090/exact/match.html</strong></p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;</p>
<p>&lt;body bgcolor=&rdquo;white&rdquo;&gt;</p>
<p>&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;</p>
<p>&lt;hr&gt;&lt;center&gt;nginx/1.1.0&lt;/center&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>[root@web108 ~]#</p>
<p>&nbsp;</p>
<p>结果进一步验证了&ldquo;普通&nbsp;location&nbsp;&rdquo;的&ldquo;严格精确&rdquo;匹配会终止对正则&nbsp;location&nbsp;的搜索。这里我们小结下&ldquo;普通&nbsp;location&rdquo;与&ldquo;正则&nbsp;location&nbsp;&rdquo;的匹配规则：先匹配普通&nbsp;location&nbsp;，再匹配正则&nbsp;location&nbsp;，但是如果普通&nbsp;location&nbsp;的匹配结果恰好是&ldquo;严格精确（&nbsp;exact match&nbsp;）&rdquo;的，则&nbsp;nginx&nbsp;不再尝试后面的正则&nbsp;location&nbsp;；如果普通&nbsp;location&nbsp;的匹配结果是&ldquo;最大前缀&rdquo;，则正则&nbsp;location&nbsp;的匹配覆盖普通&nbsp;location&nbsp;的匹配。也就是前面说的&ldquo;正则&nbsp;location&nbsp;让步普通location&nbsp;的严格精确匹配结果，但覆盖普通&nbsp;location&nbsp;的最大前缀匹配结果&rdquo;。</p>
<h3><a name="t6" rel="nofollow"></a>#3&nbsp;普通&nbsp;location&nbsp;的&ldquo;显式&rdquo;严格匹配和&ldquo;&nbsp;^~&nbsp;&rdquo;&nbsp;前缀</h3>
<p>上面我们演示的普通&nbsp;location&nbsp;都是不加任何前缀的，其实普通&nbsp;location&nbsp;也可以加前缀：&ldquo;&nbsp;^~&nbsp;&rdquo;和&ldquo;&nbsp;=&nbsp;&rdquo;。其中&ldquo;&nbsp;^~&rdquo;的意思是&ldquo;非正则，不需要继续正则匹配&rdquo;，也就是通常我们的普通&nbsp;location&nbsp;，还会继续搜索正则&nbsp;location&nbsp;（恰好严格精确匹配除外），但是&nbsp;nginx&nbsp;很人性化允许配置人员告诉&nbsp;nginx&nbsp;某条普通&nbsp;location&nbsp;，无论最大前缀匹配，还是严格精确匹配都终止继续搜索正则&nbsp;location&nbsp;；而&ldquo;&nbsp;=&nbsp;&rdquo;则表达的是普通&nbsp;location&nbsp;不允许&ldquo;最大前缀&rdquo;匹配结果，必须严格等于，严格精确匹配。</p>
<p>&nbsp;</p>
<p>例题&nbsp;3&nbsp;：&ldquo;&nbsp;^~&nbsp;&rdquo;前缀的使用</p>
<p>server {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9090;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;localhost;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location /exact/match.html {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>location ^~ / {</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;&nbsp;html;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;&nbsp;index.html index.htm;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location ~ \.html$ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>&nbsp;</p>
<p>把例题&nbsp;2&nbsp;中的&nbsp;location / {}&nbsp;修改成&nbsp;location ^~ / {}&nbsp;，再看看测试结果：</p>
<table>
<tbody>
<tr>
<td width="310">URI&nbsp;请求</td>
<td width="132">修改前</td>
<td width="127">修改后</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/</td>
<td width="132">403 Forbidden</td>
<td width="127">403 Forbidden</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/index.html</td>
<td width="132">Welcome to nginx!</td>
<td width="127">403 Forbidden</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/index_notfound.html</td>
<td width="132">404 Not Found</td>
<td width="127">403 Forbidden</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/exact/match.html</td>
<td width="132">404 Not Found</td>
<td width="127">404 Not Found</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>除了&nbsp;GET /exact/match.html&nbsp;是&nbsp;404 Not Found&nbsp;，其余都是&nbsp;403 Forbidden&nbsp;，原因很简单所有请求都是以&ldquo;&nbsp;/&nbsp;&rdquo;开头，所以所有请求都能匹配上&ldquo;&nbsp;/&nbsp;&rdquo;普通&nbsp;location&nbsp;，但普通&nbsp;location&nbsp;的匹配原则是&ldquo;最大前缀&rdquo;，所以只有/exact/match.html&nbsp;匹配到&nbsp;location /exact/match.html {allow all;}&nbsp;，其余都&nbsp;location ^~ / {deny all;}&nbsp;并终止正则搜索。</p>
<p>&nbsp;</p>
<p>例题&nbsp;4&nbsp;：&ldquo;&nbsp;=&nbsp;&rdquo;前缀的使用</p>
<p>server {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9090;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;localhost;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location /exact/match.html {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>location = / {</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;&nbsp;html;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;&nbsp;index.html index.htm;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location ~ \.html$ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>例题&nbsp;4&nbsp;相对例题&nbsp;2&nbsp;把&nbsp;location / {}&nbsp;修改成了&nbsp;location = / {}&nbsp;，再次测试结果：</p>
<table>
<tbody>
<tr>
<td width="310">URI&nbsp;请求</td>
<td width="132">修改前</td>
<td width="127">修改后</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/</td>
<td width="132">403 Forbidden</td>
<td width="127">403 Forbidden</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/index.html</td>
<td width="132">Welcome to nginx!</td>
<td width="127">Welcome to nginx!</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/index_notfound.html</td>
<td width="132">404 Not Found</td>
<td width="127">404 Not Found</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/exact/match.html</td>
<td width="132">404 Not Found</td>
<td width="127">404 Not Found</td>
</tr>
<tr>
<td width="310"><strong>curl http://localhost:9090/test.jsp</strong></td>
<td width="132"><strong>403 Forbidden</strong></td>
<td width="127"><strong>404 Not Found</strong></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>最能说明问题的测试是&nbsp;GET /test.jsp&nbsp;，实际上&nbsp;/test.jsp&nbsp;没有匹配正则&nbsp;location&nbsp;（&nbsp;location ~\.html$&nbsp;），也没有匹配&nbsp;location = / {}&nbsp;，如果按照&nbsp;location / {}&nbsp;的话，会&ldquo;最大前缀&rdquo;匹配到普通&nbsp;location / {}&nbsp;，结果是&nbsp;deny all&nbsp;。</p>
<h3><a name="t7" rel="nofollow"></a>#4&nbsp;正则&nbsp;location&nbsp;与编辑顺序</h3>
<p>location&nbsp;的指令与编辑顺序无关，这句话不全对。对于普通&nbsp;location&nbsp;指令，匹配规则是：最大前缀匹配（与顺序无关），如果恰好是严格精确匹配结果或者加有前缀&ldquo;&nbsp;^~&nbsp;&rdquo;或&ldquo;&nbsp;=&nbsp;&rdquo;（符号&ldquo;&nbsp;=&nbsp;&rdquo;只能严格匹配，不能前缀匹配），则停止搜索正则&nbsp;location&nbsp;；但对于正则&nbsp;location&nbsp;的匹配规则是：按编辑顺序逐个匹配（与顺序有关），只要匹配上，就立即停止后面的搜索。</p>
<p>&nbsp;</p>
<p>配置&nbsp;3.1</p>
<p>server {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9090;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;localhost;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location ~ \.html$ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location ~ ^/prefix/.*\.html$ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny all;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</p>
<p>&nbsp;</p>
<p>}</p>
<p>配置&nbsp;3.2</p>
<p>server {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9090;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;localhost;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location ~ ^/prefix/.*\.html$ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny all;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location ~ \.html$ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;</p>
<p>&nbsp;</p>
<p>}</p>
<p>&nbsp;</p>
<p>测试结果：</p>
<table>
<tbody>
<tr>
<td width="310">URI&nbsp;请求</td>
<td width="132">配置&nbsp;3.1</td>
<td width="127">配置&nbsp;3.2</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/regextest.html</td>
<td width="132">404 Not Found</td>
<td width="127">404 Not Found</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/prefix/regextest.html</td>
<td width="132">404 Not Found</td>
<td width="127">403 Forbidden</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>解释：</p>
<p>Location ~ ^/prefix/.*\.html$ {deny all;}&nbsp;表示正则&nbsp;location&nbsp;对于以&nbsp;/prefix/&nbsp;开头，&nbsp;.html&nbsp;结尾的所有&nbsp;URI&nbsp;请求，都拒绝访问；&nbsp;&nbsp;&nbsp;location ~\.html${allow all;}&nbsp;表示正则&nbsp;location&nbsp;对于以&nbsp;.html&nbsp;结尾的&nbsp;URI&nbsp;请求，都允许访问。&nbsp;实际上，prefix&nbsp;的是&nbsp;~\.html$&nbsp;的子集。</p>
<p>在&ldquo;配置&nbsp;3.1&nbsp;&rdquo;下，两个请求都匹配上&nbsp;location ~\.html$ {allow all;}&nbsp;，并且停止后面的搜索，于是都允许访问，&nbsp;404 Not Found&nbsp;；在&ldquo;配置&nbsp;3.2&nbsp;&rdquo;下，&nbsp;/regextest.html&nbsp;无法匹配&nbsp;prefix&nbsp;，于是继续搜索&nbsp;~\.html$&nbsp;，允许访问，于是&nbsp;404 Not Found&nbsp;；然而&nbsp;/prefix/regextest.html&nbsp;匹配到&nbsp;prefix&nbsp;，于是&nbsp;deny all&nbsp;，&nbsp;403 Forbidden&nbsp;。</p>
<p>&nbsp;</p>
<p>配置&nbsp;3.3</p>
<p>server {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9090;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;localhost;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;/prefix/ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny all;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;/prefix/mid/ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</p>
<p>&nbsp;</p>
<p>}</p>
<p>配置&nbsp;3.4</p>
<p>server {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9090;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;localhost;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;/prefix/mid/ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;/prefix/ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny all;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</p>
<p>}</p>
<p>测试结果：</p>
<table>
<tbody>
<tr>
<td width="310">URI&nbsp;请求</td>
<td width="132">配置&nbsp;3.1</td>
<td width="127">配置&nbsp;3.2</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/prefix/t.html</td>
<td width="132">403 Forbidden</td>
<td width="127">403 Forbidden</td>
</tr>
<tr>
<td width="310">curl http://localhost:9090/prefix/mid/t.html</td>
<td width="132">404 Not Found</td>
<td width="127">404 Not Found</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>测试结果表明：普通&nbsp;location&nbsp;的匹配规则是&ldquo;最大前缀&rdquo;匹配，而且与编辑顺序无关。</p>
<p>&nbsp;</p>
<h3><a name="t8" rel="nofollow"></a>#5 &ldquo;@&rdquo;&nbsp;前缀&nbsp;Named Location&nbsp;使用</h3>
<p>REFER:&nbsp;&nbsp;<a href="http://wiki.nginx.org/HttpCoreModule#error_page" rel="nofollow">http://wiki.nginx.org/HttpCoreModule#error_page</a></p>
<p>假设配置如下：</p>
<p>server {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9090;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;localhost;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;/ {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;&nbsp;html;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;&nbsp;index.html index.htm;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow all;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#error_page 404&nbsp;<a href="http://www.baidu.com/" rel="nofollow">http://www.baidu.com</a>&nbsp;#&nbsp;直接这样是不允许的</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_page 404 = @fallback;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location @fallback {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass http://www.baidu.com;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>&nbsp;</p>
<p>上述配置文件的意思是：如果请求的&nbsp;URI&nbsp;存在，则本&nbsp;nginx&nbsp;返回对应的页面；如果不存在，则把请求代理到baidu.com&nbsp;上去做个弥补（注：&nbsp;nginx&nbsp;当发现&nbsp;URI&nbsp;对应的页面不存在，&nbsp;HTTP_StatusCode&nbsp;会是&nbsp;404&nbsp;，此时error_page 404&nbsp;指令能捕获它）。</p>
<p>&nbsp;</p>
<p>测试一：</p>
<p>[root@web108 ~]#&nbsp;<strong>curl http://localhost:9090/nofound.html -i</strong></p>
<p>HTTP/1.1 302 Found</p>
<p>Server: nginx/1.1.0</p>
<p>Date: Sat, 06 Aug 2011 08:17:21 GMT</p>
<p>Content-Type: text/html; charset=iso-8859-1</p>
<p>Location: http://localhost:9090/search/error.html</p>
<p>Connection: keep-alive</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:17:21 GMT</p>
<p>Content-Length: 222</p>
<p>&nbsp;</p>
<p>&lt;!DOCTYPE HTML PUBLIC &ldquo;-//IETF//DTD HTML 2.0//EN&rdquo;&gt;</p>
<p>&lt;html&gt;&lt;head&gt;</p>
<p>&lt;title&gt;302 Found&lt;/title&gt;</p>
<p>&lt;/head&gt;&lt;body&gt;</p>
<p>&lt;h1&gt;Found&lt;/h1&gt;</p>
<p>&lt;p&gt;The document has moved &lt;a href=&rdquo;http://www.baidu.com/search/error.html&rdquo;&gt;here&lt;/a&gt;.&lt;/p&gt;</p>
<p>&lt;/body&gt;&lt;/html&gt;</p>
<p>[root@web108 ~]#</p>
<p>&nbsp;</p>
<p>当我们&nbsp;GET /nofound.html&nbsp;发送给本&nbsp;nginx&nbsp;，&nbsp;nginx&nbsp;找不到对应的页面，于是&nbsp;error_page 404 = @fallback&nbsp;，请求被代理到&nbsp;<a href="http://www.baidu.com/" rel="nofollow">http://www.baidu.com</a>&nbsp;，于是&nbsp;nginx&nbsp;给&nbsp;http://www.baidu.com&nbsp;发送了&nbsp;GET /nofound.html&nbsp;，但/nofound.html&nbsp;页面在百度也不存在，百度&nbsp;302&nbsp;跳转到错误页。</p>
<p>直接访问&nbsp;<a href="http://www.baidu.com/nofound.html" rel="nofollow">http://www.baidu.com/nofound.html</a>&nbsp;结果：</p>
<p>[root@web108 ~]#&nbsp;curl http://www.baidu.com/nofound.html -i</p>
<p>HTTP/1.1 302 Found</p>
<p>Date: Sat, 06 Aug 2011 08:20:05 GMT</p>
<p>Server: Apache</p>
<p>Location: http://www.baidu.com/search/error.html</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:20:05 GMT</p>
<p>Content-Length: 222</p>
<p>Connection: Keep-Alive</p>
<p>Content-Type: text/html; charset=iso-8859-1</p>
<p>&nbsp;</p>
<p>&lt;!DOCTYPE HTML PUBLIC &ldquo;-//IETF//DTD HTML 2.0//EN&rdquo;&gt;</p>
<p>&lt;html&gt;&lt;head&gt;</p>
<p>&lt;title&gt;302 Found&lt;/title&gt;</p>
<p>&lt;/head&gt;&lt;body&gt;</p>
<p>&lt;h1&gt;Found&lt;/h1&gt;</p>
<p>&lt;p&gt;The document has moved &lt;a href=&rdquo;http://www.baidu.com/search/error.html&rdquo;&gt;here&lt;/a&gt;.&lt;/p&gt;</p>
<p>&lt;/body&gt;&lt;/html&gt;</p>
<p>[root@web108 ~]#</p>
<p>&nbsp;</p>
<p>测试二：访问一个&nbsp;nginx&nbsp;不存在，但&nbsp;baidu&nbsp;存在的页面</p>
<p>[root@web108 ~]#&nbsp;curl http://www.baidu.com/duty/ -i</p>
<p>HTTP/1.1 200 OK</p>
<p>Date: Sat, 06 Aug 2011 08:21:56 GMT</p>
<p>Server: Apache</p>
<p>P3P: CP=&rdquo; OTI DSP COR IVA OUR IND COM &rdquo;</p>
<p>P3P: CP=&rdquo; OTI DSP COR IVA OUR IND COM &rdquo;</p>
<p>Set-Cookie: BAIDUID=5C5D2B2FD083737A0C88CA7075A6601A:FG=1; expires=Sun, 05-Aug-12 08:21:56 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Set-Cookie: BAIDUID=5C5D2B2FD083737A2337F78F909CCB90:FG=1; expires=Sun, 05-Aug-12 08:21:56 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Last-Modified: Wed, 05 Jan 2011 06:44:53 GMT</p>
<p>ETag: &ldquo;d66-49913b8efe340&Prime;</p>
<p>Accept-Ranges: bytes</p>
<p>Content-Length: 3430</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:21:56 GMT</p>
<p>Vary: Accept-Encoding,User-Agent</p>
<p>Connection: Keep-Alive</p>
<p>Content-Type: text/html</p>
<p>&nbsp;</p>
<p>&lt;!DOCTYPE HTML PUBLIC &ldquo;-//W3C//DTD HTML 4.01 Transitional//EN&rdquo;</p>
<p>&ldquo;http://www.w3.org/TR/html4/loose.dtd&rdquo;&gt;</p>
<p>。。。。</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>显示，的确百度这个页面是存在的。</p>
<p>[root@web108 ~]#<strong>&nbsp;curl http://localhost:9090/duty/ -i</strong></p>
<p><strong>HTTP/1.1 200 OK</strong></p>
<p>Server: nginx/1.1.0</p>
<p>Date: Sat, 06 Aug 2011 08:23:23 GMT</p>
<p>Content-Type: text/html</p>
<p>Connection: keep-alive</p>
<p>P3P: CP=&rdquo; OTI DSP COR IVA OUR IND COM &rdquo;</p>
<p>P3P: CP=&rdquo; OTI DSP COR IVA OUR IND COM &rdquo;</p>
<p>Set-Cookie: BAIDUID=8FEF0A3A2C31D277DCB4CC5F80B7F457:FG=1; expires=Sun, 05-Aug-12 08:23:23 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Set-Cookie: BAIDUID=8FEF0A3A2C31D277B1F87691AFFD7440:FG=1; expires=Sun, 05-Aug-12 08:23:23 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Last-Modified: Wed, 05 Jan 2011 06:44:53 GMT</p>
<p>ETag: &ldquo;d66-49913b8efe340&Prime;</p>
<p>Accept-Ranges: bytes</p>
<p>Content-Length: 3430</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:23:23 GMT</p>
<p>Vary: Accept-Encoding,User-Agent</p>
<p>&nbsp;</p>
<p>&lt;!DOCTYPE HTML PUBLIC &ldquo;-//W3C//DTD HTML 4.01 Transitional//EN&rdquo;</p>
<p>&ldquo;http://www.w3.org/TR/html4/loose.dtd&rdquo;&gt;</p>
<p>&lt;html&gt;</p>
<p>。。。</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>当&nbsp;curl http://localhost:9090/duty/ -i&nbsp;时，&nbsp;nginx&nbsp;没找到对应的页面，于是&nbsp;error_page = @fallback&nbsp;，把请求代理到&nbsp;baidu.com&nbsp;。注意这里的&nbsp;error_page = @fallback&nbsp;不是靠重定向实现的，而是所说的&ldquo;&nbsp;internally redirected&nbsp;（forward&nbsp;）&rdquo;。</p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


	</div>
	
	<div class="postfoot">
		posted on <span id="post-date">2014-12-17 14:51</span> <a href='http://www.cnblogs.com/lidabo/'>DoubleLi</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href ="https://i.cnblogs.com/EditPosts.aspx?postid=4169396" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4169396);return false;">收藏</a>
	</div>
</div>
<script type="text/javascript">var allowComments=true,cb_blogId=65590,cb_entryId=4169396,cb_blogApp=currentBlogApp,cb_blogUserGuid='8e506bcc-b700-df11-ba8f-001cf0cd104b',cb_entryCreatedDate='2014/12/17 14:51:00';loadViewCount(cb_entryId);</script>

</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<div id='ad_c1' class='c_ad_block'></div>
<div id='under_post_news'></div>
<div id='ad_c2' class='c_ad_block'></div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


</div>
<div class="footer">

<p id="footer">
	Powered by: 
	<br />
	
	<a id="Footer1_Hyperlink3" NAME="Hyperlink1" href="http://www.cnblogs.com/" style="font-family:Verdana;font-size:12px;">博客园</a>
	<br />
	Copyright &copy; DoubleLi
</p>
</div>
</body>
</html>
