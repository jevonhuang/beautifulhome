知乎

<https://www.zhihu.com/>

  * //注册知乎

    <javascript:;>
  * 登录

    <javascript:;>

提问

知乎搜索
搜索

  * 首页

    <https://www.zhihu.com/>
  * 话题

    <https://www.zhihu.com/topic>
  * 发现

    <https://www.zhihu.com/explore>

 
消息

用户

赞同和感谢

查看全部 »

<https://www.zhihu.com/notifications> //
<https://www.zhihu.com/settings/notification>
x

<javascript:;>

编程

<https://www.zhihu.com/topic/19554298> X 的原理

<https://www.zhihu.com/topic/19561178> 并发峰值

<https://www.zhihu.com/topic/19582037> epoll

<https://www.zhihu.com/topic/19594919> kqueue

<https://www.zhihu.com/topic/19594923> 多线程

<https://www.zhihu.com/topic/19619463>


epoll 或者 kqueue 的原理是什么？

为什么epoll和kqueue可以用基于事件的方式，单线程的实现并发？我没看过linux
内核，对这方面一直有疑问……
*
*
*可能我没有说太明白，我知道您说的这些，我是想了解底层原理。在底层，linux
内核是如何知道这些事件的，通过轮询吗？ *
//1 条评论 <#> //分享
 
 <#>
默认排序 按时间排序

<https://www.zhihu.com/question/20122137?sort=created>
/

/


14 个回答

/

/ 85 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/windoze> 徐辰
<https://www.zhihu.com/people/windoze>GOP SOOP GHOP Coder
85 人赞同 <#>
原理其它答案讲得差不多了，我就补一句，从kernel层面将，事件产生有可能不是
由硬件中断触发的，在一定情况下kernel的确会轮询，因为响应硬件中断是一个成
本比较高的操作。 以网卡为例，当数据量很少的时候，每来一个数据包网卡都回
产生一个中断，kernel响… 显示全部
<https://www.zhihu.com/question/20122137/answer/54153089>
原理其它答案讲得差不多了，我就补一句，从kernel层面将，事件产生有可能不是
由硬件中断触发的，在一定情况下kernel的确会轮询，因为响应硬件中断是一个成
本比较高的操作。
以网卡为例，当数据量很少的时候，每来一个数据包网卡都回产生一个中
断，kernel响应这个中断，从网卡缓冲区中读出数据放进协议栈处理，当满足一定
条件时，kernel回调用户代码，这里的“回调”一般情况下是指从一个kernel
syscall中返回(在此之前用户代码一直处于block状态)。
当数据量很大时，每个包都产生一个中断就划不来了，此时kernel可以启动
interrupt coalescing机制，让网卡做中断合并，也就是说来足够多的数据包或者
等待一个timeout才会产生一个中断，kernel在响应中断时会把所有数据一起读出
来处理，这样可以有效的降低中断次数。
当数据量更大时，网卡缓冲区里几乎总是有未处理的数据，此时kernel干脆会禁掉
网卡的中断，切换到轮询处理的模式，说白了就是跑一个忙循环不停地读网卡缓冲
区里的数据，这样综合开销更低。

发布于 2015-07-07
<https://www.zhihu.com/question/20122137/answer/54153089> //12 条评论
<#> //感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 115 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/zsummer> 夏天
<https://www.zhihu.com/people/zsummer>生命是一场永不停歇的追寻
115 人赞同 <#>
*收到了在知乎的第一个赞.* *网卡设备对应一个中断号, 当网卡收到网络端的消
息的时候会向CPU发起中断请求, 然后CPU处理该请求. 通过驱动程序 进而操作系
统得到通知, 系统然后通知epoll, epoll通知用户代码. 大致流程是这样.*
*-----------* *在内核的最底层是中断 …@蓝形参
<https://www.zhihu.com/people/b7822d554cfe3ed3118815a0339fe4c3> 的回答.*
显示全部 <https://www.zhihu.com/question/20122137/answer/15999888>
*收到了在知乎的第一个赞.*
*网卡设备对应一个中断号, 当网卡收到网络端的消息的时候会向CPU发起中断请
求, 然后CPU处理该请求. 通过驱动程序 进而操作系统得到通知, 系统然后通知
epoll, epoll通知用户代码. 大致流程是这样.*
*-----------*
*在内核的最底层是中断 类似系统回调的机制 不是轮询, 在这个基础上再去看 @
蓝形参 <https://www.zhihu.com/people/b7822d554cfe3ed3118815a0339fe4c3>
的回答.*

编辑于 2013-07-08
<https://www.zhihu.com/question/20122137/answer/15999888> //18 条评论
<#> //感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 662 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/thynson> 蓝形参
<https://www.zhihu.com/people/thynson>黑魔法书编撰者
662 人赞同 <#>
2013-10-27更新：由于此文陆陆续续收到赞同，而且其中有些地方并不完全正确，
特在本文最后予以订正 我不了解楼主的层次，我必须从很多基础的概念开始构建
这个答案，并且可能引申到很多别的问题。 首先我们来定义流的概念，一个流可
以是文件，socket，pipe等… 显示全部
<https://www.zhihu.com/question/20122137/answer/14049112>
2013-10-27更新：由于此文陆陆续续收到赞同，而且其中有些地方并不完全正确，
特在本文最后予以订正

我不了解楼主的层次，我必须从很多基础的概念开始构建这个答案，并且可能引申
到很多别的问题。

首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操
作的内核对象。
不管是文件，还是套接字，还是管道，我们都可以把他们看作流。
之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我
们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，*但是流中还
没有数据*，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把
数据传回来），这时候该怎么办？

  * 阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什
    么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能
    做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话
    （假定一定能叫醒你）。
  * 非阻塞*忙*轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要
    知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”

很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员
大量的时间。
大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少
的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵
的时间片了。

为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事
件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知
道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对
于用户空间而言。对于内核来说，也需要缓冲区。
假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。

 1. 假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写
    入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉
    Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。
 2. 但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写
    入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内
    核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会
    产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为
    “缓冲区满”。
 3. 假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告
    诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把
    这个事件叫做“缓冲区非满”
 4. 也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道
    内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间
    定为“缓冲区空”。

这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满
（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。
这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学
习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。

然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的
I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程
(pthread_create)，很不幸这两种方法效率都不高。
于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把
一个流从阻塞模式切换到非阻塞模式再此不予讨论）：
while true {
for i in stream[]; {
if i has data
read until unavailable
}
}
我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流
了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费
CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而
非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至
直接忽略。

为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来
又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以
同时观察许多流的I/O事件，在空闲的时候，*会把当前线程阻塞掉*，当有一个或
多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流
（于是我们可以把“忙”字去掉了）。代码长这样:
while true {
select(streams[])
for i in streams[] {
if i has data
read until unavailable
}
}
于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问
题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流
（可能有一个，多个，甚至全部），我们只能*无差别轮询*所有流，找出能读出数
据，或者写入数据的流，对他们进行操作。
但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无
差别轮询时间就越长。再次
*说了这么多，终于能好好解释epoll了*
epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发
生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度
降低到了O(k)，k为产生I/O事件的流的个数，也有认为O(1)的[更新 1]）
在讨论epoll的实现细节之前，先把epoll的相关操作列出[更新 2]：

  * epoll_create 创建一个epoll对象，一般epollfd = epoll_create()
  * epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一
    个流的某一个事件
    比如
    epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//有缓冲区内有数
    据时epoll_wait返回
    epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//缓冲区可写入时
    epoll_wait返回
  * epoll_wait(epollfd,...)等待直到注册的事件发生

（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，
并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。
一个epoll模式的代码大概的样子是：
while true {
active_stream[] = epoll_wait(epollfd)
for i in active_stream[] {
read or write till unavailable
}
}
限于篇幅，我只说这么多，以揭示原理性的东西，至于epoll的使用细节，请参考
man和google，实现细节，请参阅linux kernel source。
======================================
[更新1]: 原文为O(1)，但实际上O(k)更为准确
[更新2]: 原文所列第二点说法让人产生EPOLLIN/EPOLLOUT等同于“缓冲区非空”和
“缓冲区非满”的事件，但并非如此，详细可以Google关于epoll的边缘触发和水平
触发。

编辑于 2013-10-27
<https://www.zhihu.com/question/20122137/answer/14049112> //41 条评论
<#> //感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>
//收起

/

/ 12 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/liu-bo-39-20> 刘 波
<https://www.zhihu.com/people/liu-bo-39-20>美团/风行/国瑞数码/zinglabs
12 人赞同 <#>
linux下的NIC driver都是在有数据时，通过接口通知os。os为节省资源，关中断
后，从driver buffer狂读数据。然后，把处理给协议栈处理，拿tcp为例，当在某
些状态点时，会去wakeup相应的sock->socket_wq。wakeup的操作，就是执行挂在
这个wq上的eppoll_entry的… 显示全部
<https://www.zhihu.com/question/20122137/answer/23087726>
linux下的NIC driver都是在有数据时，通过接口通知os。os为节省资源，关中断
后，从driver buffer狂读数据。然后，把处理给协议栈处理，拿tcp为例，当在某
些状态点时，会去wakeup相应的sock->socket_wq。wakeup的操作，就是执行挂在
这个wq上的eppoll_entry的callback。这个callback就是把自己对应的epoll对象
epitem挂到epollevent的readylist上。

此时，如果你调用了epoll_wait()，那就直接从epollevent的readylist上，把
event复制给你就完了。

简单的说，就是一个生产者，消费者的方式。底层生成数据，放到readylist，用
户用epoll_wait去取。

发布于 2014-03-04
<https://www.zhihu.com/question/20122137/answer/23087726> //添加评论 <#>
//感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 6 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/nybux> nybux
<https://www.zhihu.com/people/nybux>
6 人赞同 <#>
在句柄上注册了回调函数ep_ptable_queue_proc
http://lxr.linux.no/linux+v3.12.1/fs/eventpoll.c#L1267//
<https://link.zhihu.com/?target=http%3A//lxr.linux.no/linux%2Bv3.12.1/fs/eventpoll.c%23L1267>
显示全部 <https://www.zhihu.com/question/20122137/answer/20295604>
在句柄上注册了回调函数ep_ptable_queue_proc
http://lxr.linux.no/linux+v3.12.1/fs/eventpoll.c#L1267//
<https://link.zhihu.com/?target=http%3A//lxr.linux.no/linux%2Bv3.12.1/fs/eventpoll.c%23L1267>


发布于 2013-11-24
<https://www.zhihu.com/question/20122137/answer/20295604> //2 条评论 <#>
//感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 4 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/chinaxing> lambda喵
<https://www.zhihu.com/people/chinaxing>喜欢是放肆，爱是克制
4 人赞同 <#>
根本是因为硬件就是真实世界。 那里有异步事件——中断。 所以大概不需要轮询这
么麻烦和低效。 用户太太弱了 显示全部
<https://www.zhihu.com/question/20122137/answer/54225562>
根本是因为硬件就是真实世界。

那里有异步事件——中断。

所以大概不需要轮询这么麻烦和低效。

用户太太弱了

发布于 2015-07-08
<https://www.zhihu.com/question/20122137/answer/54225562> //添加评论 <#>
//感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 5 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/yongxinge> 用心阁
<https://www.zhihu.com/people/yongxinge>学习中的老码农
5 人赞同 <#>
select/poll是通过轮询的方法来获得就绪的状态，调用select/poll后就阻塞住，
直到有就绪的文件描述符，或者超时，或者被中断。返回值是就绪的文件描述符的
个数，需要遍历作为参数传入的文件描述符的位域或数组获得哪个文件描述符。
epoll是通过后台中断的方… 显示全部
<https://www.zhihu.com/question/20122137/answer/74003925>
select/poll是通过轮询的方法来获得就绪的状态，调用select/poll后就阻塞住，
直到有就绪的文件描述符，或者超时，或者被中断。返回值是就绪的文件描述符的
个数，需要遍历作为参数传入的文件描述符的位域或数组获得哪个文件描述符。

epoll是通过后台中断的方式来获得就绪的状态，调用epoll_create创建实例，调
用epoll_ctl添加或删除监控的文件描述符，调用epoll_wait阻塞住，直到有就绪
的文件描述符，通过epoll_event参数返回就绪状态的文件描述符和事件

简单但不严谨的说：

  * 当调用epoll_ctl时，epoll就向底层（poll()，或tcp_poll()）注册了callback
  * 当文件描述符就绪时，callback函数就会被调用，callback函数就会把该文件
    描述符加入列表并唤醒epoll_wait
  * 当调用epoll_wait时，epoll只是简单地检查下列表是否为空，不为空就返
    回，为空就挂起，等待被唤醒。


通常来说select和poll属于I/O multiplexing，而epoll可以算作signal driven I/O

编辑于 2015-11-26
<https://www.zhihu.com/question/20122137/answer/74003925> //添加评论 <#>
//感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 15 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/dccmx> dccmx
<https://www.zhihu.com/people/dccmx>搞技术的
15 人赞同 <#>
epoll的原理就是： 你把要监控读写的文件交给内核（epoll_add) 设置你关心的
事件（epoll_ctl），比如读事件 然后等（epoll_wait），此时，如果没有哪个文
件有你关心的事件，则休眠，直到有事件，被唤醒 然后返回那些事件 实现并发，
还需要配合非阻塞的读写… 显示全部
<https://www.zhihu.com/question/20122137/answer/14046875>
epoll的原理就是：
你把要监控读写的文件交给内核（epoll_add)
设置你关心的事件（epoll_ctl），比如读事件
然后等（epoll_wait），此时，如果没有哪个文件有你关心的事件，则休眠，直到
有事件，被唤醒
然后返回那些事件

实现并发，还需要配合非阻塞的读写。这样就可以一下搜集一大把文件（套接
字），然后一下读写一大把文件（不会因为某个文件慢而阻塞），这样来实现并发。

发布于 2012-03-15
<https://www.zhihu.com/question/20122137/answer/14046875> //2 条评论 <#>
//感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 7 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/husitan> husitan
<https://www.zhihu.com/people/husitan>养老程序员 @ http://gdi.plus//
<https://link.zhihu.com/?target=http%3A//gdi.plus>
7 人赞同 <#>
Epoll的优势在于，由接收数据的OS来负责通知你有数据可以操作，因为OS是知道
什么时候有数据的。 仍然用蓝形参 <http://www.zhihu.com/people/thynson>的
快递例子来说，EPoll的优势就是，你可以随便做其他的事情，当有快递来的时
候，他给你打电话让你来拿，你空了的时候下来拿就好了。 不像阻塞那样… 显示
全部 <https://www.zhihu.com/question/20122137/answer/44283594>
Epoll的优势在于，由接收数据的OS来负责通知你有数据可以操作，因为OS是知道
什么时候有数据的。
仍然用蓝形参 <http://www.zhihu.com/people/thynson>的快递例子来说，EPoll
的优势就是，你可以随便做其他的事情，当有快递来的时候，他给你打电话让你来
拿，你空了的时候下来拿就好了。
不像阻塞那样需要一直在窗边看着快递来没来，也不需要像select那样不停地打电
话问快递来没来。尤其是在快递比较多的时候，select需要问快递你没有你的快
递，快递说有的时候，你还需要逐个问某一个包裹到没到；EPoll会直接告诉你，
你的哪个包裹的快递到了。

发布于 2015-04-09
<https://www.zhihu.com/question/20122137/answer/44283594> //2 条评论 <#>
//感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 0 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/wa-boer> boerwa
<https://www.zhihu.com/people/wa-boer>奔跑的犀牛
又不是理论意义上的并行 显示全部
<https://www.zhihu.com/question/20122137/answer/64421502>
又不是理论意义上的并行

发布于 2015-09-20
<https://www.zhihu.com/question/20122137/answer/64421502> //添加评论 <#>
//感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 3 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/lin-cang-2> 林沧
<https://www.zhihu.com/people/lin-cang-2>世外人法无定法，然后知非法法也
3 人赞同 <#>
严格来说epoll也是轮询，只不过是对产生了io事件的流进行轮询，而不需要像
selec或poll那样对所有的流都进行轮询。所以才被称为epoll，说明其本质上还是
轮询（poll）。 至于linux内核是如何知道io事件发生的，这就不是轮询而是中断
了。中断的作用就相当于你… 显示全部
<https://www.zhihu.com/question/20122137/answer/53006058>
严格来说epoll也是轮询，只不过是对产生了io事件的流进行轮询，而不需要像
selec或poll那样对所有的流都进行轮询。所以才被称为epoll，说明其本质上还是
轮询（poll）。

至于linux内核是如何知道io事件发生的，这就不是轮询而是中断了。中断的作用
就相当于你这正在进行某项工作或者睡觉，突然电话铃声响了，你中断了正在进行
的工作或者从睡眠中惊醒开始接电话，电话铃声就相当于中断事件发生。中断其实
就是通知，你不必通过轮询去查询某事件是否发生，就如同你不必不断地打电话给
快递公司查询你的快递是否送达？而是由快递员在你的快递送达时按你家的门铃或
者打电话通知你。所以，linux内核不是通过轮询而是通过中断知道io事件发生并
通知epoll进行处理，但如果有多个io事件同时发生,epoll还是要通过轮询来处理的。

编辑于 2015-06-28
<https://www.zhihu.com/question/20122137/answer/53006058> //1 条评论 <#>
//感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 0 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/zhi-fou-6-6> 知否
<https://www.zhihu.com/people/zhi-fou-6-6>知之为知之
很多时候对一个东西的不理解是因为不知道别人当时为什么这么做。 我们从服务
器的角度出发，需要做这几件事情： 1.请求什么时候过来 2.请求中的数据什么时
候过来 知道了要做什么，接下来的问题就是用什么方法去做 方法1.用一个线程监
视请求有没有过来，再用… 显示全部
<https://www.zhihu.com/question/20122137/answer/120388023>
很多时候对一个东西的不理解是因为不知道别人当时为什么这么做。
我们从服务器的角度出发，需要做这几件事情：
1.请求什么时候过来
2.请求中的数据什么时候过来
知道了要做什么，接下来的问题就是用什么方法去做
方法1.用一个线程监视请求有没有过来，再用一个线程去处理过来的过来请求中的
数据。（一请求已线程模型）
方法2.用一个线程监视请求是否过来，请求中的数据是否过来所有这些事件，再用
一个线程去处理对应的事件。（select模型）
至于其他的poll、epoll都是对select的优化，基本想法是一致的。
更上一层的Java Nio、netty都是对select这类模型的封装。

发布于 2016-09-04
<https://www.zhihu.com/question/20122137/answer/120388023> //添加评论
<#> //感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 0 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/chuanmingliu> 瓦斯寓情于景
<https://www.zhihu.com/people/chuanmingliu>伪Linux C++后台开发攻城狮
《TLPI》下册，第63章，1088页，“其他备选的I/O模型” 显示全部
<https://www.zhihu.com/question/20122137/answer/94434267>
《TLPI》下册，第63章，1088页，“其他备选的I/O模型”

发布于 2016-04-09
<https://www.zhihu.com/question/20122137/answer/94434267> //添加评论 <#>
//感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>

/

/ 0 赞同

// 反对，不会显示你的姓名

<https://www.zhihu.com/people/bao-yi-61> 宝仪
<https://www.zhihu.com/people/bao-yi-61>儿童推车
：http://zuoyituiche.com//
<https://link.zhihu.com/?target=http%3A//zuoyituiche.com>
简单的说，就是一个生产者，消费者的方式。底层生成数据，放到readylist，用
户用epoll_wait去取 显示全部
<https://www.zhihu.com/question/20122137/answer/54196354>
简单的说，就是一个生产者，消费者的方式。底层生成数据，放到readylist，用
户用epoll_wait去取

发布于 2015-07-07
<https://www.zhihu.com/question/20122137/answer/54196354> //添加评论 <#>
//感谢 <#> //分享
 
 <#> //收藏 <#> • 没有帮助 <#> • 举报 <#> • 作者保留权利
<https://www.zhihu.com/terms#sec-licence-1>
1 个回答被折叠 <javascript:;> （为什么？
<https://www.zhihu.com/question/20120168>）

//修改 <javascript:;>
我来回答这个问题
 
 
 

写回答…

拖拽至此处上传
想用 @ 提到谁？
我要回答 <javascript:>
匿名  

// <https://www.zhihu.com/terms#sec-licence-6>

发布回答 <javascript:>
//清除草稿 <#>


  加入知乎


    与世界分享你的知识、经验和见解

验证码
已有帐号？登录 <#>


  登录知乎


    与世界分享你的知识、经验和见解

验证码
记住我 · 无法登录？
社交帐号登录

微信 微博 QQ

下载知乎 App

关注问题 1428 人关注该问题
换一换


      相关问题

  * 多线程有什么用？ <https://www.zhihu.com/question/19901763> 26 个回答
  * 线程崩溃是否会造成进程崩溃？
    <https://www.zhihu.com/question/22397613> 11 个回答
  * 开发多线程的程序应该注意哪些问题？
    <https://www.zhihu.com/question/24047885> 10 个回答
  * Linux 开发，使用多线程还是用 IO 复用 select/epoll？
    <https://www.zhihu.com/question/20114168> 26 个回答
  * IO 多路复用是什么意思？ <https://www.zhihu.com/question/32163005> 13
    个回答
  * 语音识别的技术原理是什么？ <https://www.zhihu.com/question/20398418>
    13 个回答
  * epoll编程，如何实现高并发服务器开发？
    <https://www.zhihu.com/question/21516827> 16 个回答
  * 俄罗斯方块一旦开始，就不会「消」完么？是有什么原理？还是程序设计就是
    这样？ <https://www.zhihu.com/question/19796936> 11 个回答
  * Nginx 和 Apache 在 Windows 下的性能表现谁更好？
    <https://www.zhihu.com/question/19618688> 18 个回答

  * 刘看山 <https://liukanshan.zhihu.com/>
  * 移动应用 <https://www.zhihu.com/app>
  * 加入知乎 <https://www.zhihu.com/careers>
  * 知乎协议 <https://www.zhihu.com/terms>
  * 联系我们 <https://www.zhihu.com/contact>

© 2016 知乎
加载中…

<javascript:;>

勾选后，我们将限制其他用户的复制操作，并给予提醒

查看演示

选择语言
/

/
